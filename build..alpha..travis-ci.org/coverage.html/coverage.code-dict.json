{"/home/travis/build/npmtest/node-npmtest-telegraf/test.js":"/* istanbul instrument in package npmtest_telegraf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-telegraf/lib.npmtest_telegraf.js":"/* istanbul instrument in package npmtest_telegraf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_telegraf = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_telegraf = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-telegraf/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-telegraf && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_telegraf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_telegraf\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_telegraf.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_telegraf.rollup.js'] =\n            local.assetsDict['/assets.npmtest_telegraf.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_telegraf.__dirname + '/lib.npmtest_telegraf.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/index.js":"const Telegraf = require('./telegraf')\nObject.assign(Telegraf, {\n  Telegram: require('./telegram'),\n  TelegramError: require('./network/error'),\n  Extra: require('./helpers/extra'),\n  Markup: require('./helpers/markup'),\n  memorySession: require('./core/session'),\n  Composer: require('./core/composer'),\n  Router: require('./core/router')\n})\nmodule.exports = Telegraf\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/telegraf.js":"const debug = require('debug')('telegraf:core')\nconst util = require('util')\nconst Telegram = require('./telegram')\nconst generateCallback = require('./network/webhook')\nconst Composer = require('./core/composer')\nconst Context = require('./core/context')\n\nclass Telegraf extends Composer {\n  constructor (token, options) {\n    super()\n    this.options = Object.assign({\n      retryAfter: 1,\n      handlerTimeout: 0\n    }, options)\n    this.token = token\n    this.handleError = (err) => {\n      console.error()\n      console.error((err.stack || err.toString()).replace(/^/gm, '  '))\n      console.error()\n      throw err\n    }\n    this.context = {}\n    this.state = {\n      offset: 0,\n      started: false\n    }\n  }\n\n  get token () {\n    return this.options.token\n  }\n\n  set token (token) {\n    this.options.token = token\n    this.telegram = new Telegram(this.options.token, this.options.telegram)\n  }/* eslint brace-style: 0 */\n\n  catch (handler) {\n    this.handleError = handler\n    return this\n  }\n\n  webhookCallback (path = '/') {\n    return generateCallback(path, (update, res) => this.handleUpdate(update, res), debug)\n  }\n\n  startPolling (timeout = 30, limit = 100, allowedUpdates) {\n    this.state.timeout = timeout\n    this.state.limit = limit\n    this.state.allowedUpdates = allowedUpdates\n      ? Array.isArray(allowedUpdates) ? allowedUpdates : [`${allowedUpdates}`]\n      : null\n    if (!this.state.started) {\n      this.state.started = true\n      this.fetchUpdates()\n    }\n    return this\n  }\n\n  startWebhook (path, tlsOptions, port, host, cb) {\n    const webhookCb = this.webhookCallback(path)\n    const callback = cb && typeof cb === 'function'\n      ? (req, res) => webhookCb(req, res, () => cb(req, res))\n      : webhookCb\n    this.webhookServer = tlsOptions\n      ? require('https').createServer(tlsOptions, callback)\n      : require('http').createServer(callback)\n    this.webhookServer.listen(port, host, () => {\n      debug('Webhook listening on port: %s', port)\n    })\n    return this\n  }\n\n  stop () {\n    this.state.started = false\n    if (this.webhookServer) {\n      this.webhookServer.close()\n    }\n    return this\n  }\n\n  handleUpdates (updates) {\n    if (!Array.isArray(updates)) {\n      return Promise.reject(new Error('Updates must be an array'))\n    }\n    const processAll = Promise.all(updates.map((update) => this.handleUpdate(update)))\n    if (this.options.handlerTimeout === 0) {\n      return processAll\n    }\n    return Promise.race([\n      processAll,\n      new Promise((resolve) => setTimeout(resolve, this.options.handlerTimeout))\n    ])\n  }\n\n  handleUpdate (update, webhookResponse) {\n    debug('⚡ update', update.update_id)\n    const telegram = webhookResponse\n      ? new Telegram(this.token, this.options.telegram, webhookResponse)\n      : this.telegram\n    const ctx = new Context(update, telegram, this.options)\n    Object.assign(ctx, this.context)\n    return this.middleware()(ctx).catch(this.handleError)\n  }\n\n  fetchUpdates () {\n    const { timeout, limit, offset, started, allowedUpdates } = this.state\n    if (!started) {\n      return\n    }\n    this.telegram.getUpdates(timeout, limit, offset, allowedUpdates)\n      .catch((err) => {\n        const wait = err.retryAfter || this.options.retryAfter\n        console.error(`Failed to get updates. Waiting: ${wait}s`, err)\n        return new Promise((resolve) => setTimeout(resolve, wait * 1000, []))\n      })\n      .then((updates) => this.handleUpdates(updates).then(() => updates))\n      .catch((err) => {\n        console.error('Failed to process updates.', err)\n        this.state.offset = 0\n        this.state.started = false\n        return []\n      })\n      .then((updates) => {\n        if (updates.length > 0) {\n          this.state.offset = updates[updates.length - 1].update_id + 1\n        }\n        this.fetchUpdates()\n      })\n  }\n}\n\nTelegraf.prototype.webHookCallback = util.deprecate(Telegraf.prototype.webhookCallback, 'telegraf: `webHookCallback` is deprecated. Use `webhookCallback` instead.')\nTelegraf.prototype.startWebHook = util.deprecate(Telegraf.prototype.startWebhook, 'telegraf: `startWebHook` is deprecated. Use `startWebhook` instead.')\n\nmodule.exports = Telegraf\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/telegram.js":"const util = require('util')\nconst replicators = require('./helpers/replicators')\nconst ApiClient = require('./network/client')\n\nclass Telegram extends ApiClient {\n  getMe () {\n    return this.callApi('getMe')\n  }\n\n  getFile (fileId) {\n    return this.callApi('getFile', {file_id: fileId})\n  }\n\n  getFileLink (fileId) {\n    return Promise.resolve(fileId)\n      .then((fileId) => {\n        if (fileId && fileId.file_path) {\n          return fileId\n        }\n        const id = fileId && fileId.file_id ? fileId.file_id : fileId\n        return this.getFile(id)\n      })\n      .then((file) => `${this.options.apiRoot}/file/bot${this.token}/${file.file_path}`)\n  }\n\n  getUpdates (timeout, limit, offset, allowedUpdates) {\n    let url = `getUpdates?offset=${offset}&limit=${limit}&timeout=${timeout}`\n    return this.callApi(url, {\n      allowed_updates: allowedUpdates\n    })\n  }\n\n  getWebhookInfo () {\n    return this.callApi(`getWebhookInfo`)\n  }\n\n  getGameHighScores (userId, inlineMessageId, chatId, messageId) {\n    return this.callApi(`getGameHighScores`, {\n      user_id: userId,\n      inline_message_id: inlineMessageId,\n      chat_id: chatId,\n      message_id: messageId\n    })\n  }\n\n  setGameScore (userId, score, inlineMessageId, chatId, messageId, editMessage = true, force) {\n    return this.callApi(`setGameScore`, {\n      user_id: userId,\n      score: score,\n      inline_message_id: inlineMessageId,\n      chat_id: chatId,\n      message_id: messageId,\n      disable_edit_message: !editMessage,\n      force: force\n    })\n  }\n\n  setWebhook (url, cert, maxConnections, allowedUpdates) {\n    return this.callApi('setWebhook', {\n      url: url,\n      certificate: cert,\n      max_connections: maxConnections,\n      allowed_updates: allowedUpdates\n    })\n  }\n\n  deleteWebhook () {\n    return this.callApi('deleteWebhook')\n  }\n\n  sendMessage (chatId, text, extra) {\n    return this.callApi('sendMessage', Object.assign({ chat_id: chatId, text: text }, extra))\n  }\n\n  forwardMessage (chatId, fromChatId, messageId, extra) {\n    return this.callApi('forwardMessage', Object.assign({\n      chat_id: chatId,\n      from_chat_id: fromChatId,\n      message_id: messageId\n    }, extra))\n  }\n\n  sendChatAction (chatId, action) {\n    return this.callApi('sendChatAction', { chat_id: chatId, action: action })\n  }\n\n  getUserProfilePhotos (userId, offset, limit) {\n    return this.callApi('getUserProfilePhotos', { user_id: userId, offset: offset, limit: limit })\n  }\n\n  sendLocation (chatId, latitude, longitude, extra) {\n    return this.callApi('sendLocation', Object.assign({ chat_id: chatId, latitude: latitude, longitude: longitude }, extra))\n  }\n\n  sendVenue (chatId, latitude, longitude, title, address, extra) {\n    return this.callApi('sendVenue', Object.assign({\n      chat_id: chatId,\n      latitude: latitude,\n      longitude: longitude,\n      title: title,\n      address: address\n    }, extra))\n  }\n\n  sendContact (chatId, phoneNumber, firstName, extra) {\n    return this.callApi('sendContact', Object.assign({ chat_id: chatId, phone_number: phoneNumber, first_name: firstName }, extra))\n  }\n\n  sendPhoto (chatId, photo, extra) {\n    return this.callApi('sendPhoto', Object.assign({ chat_id: chatId, photo: photo }, extra))\n  }\n\n  sendDocument (chatId, doc, extra) {\n    return this.callApi('sendDocument', Object.assign({ chat_id: chatId, document: doc }, extra))\n  }\n\n  sendAudio (chatId, audio, extra) {\n    return this.callApi('sendAudio', Object.assign({ chat_id: chatId, audio: audio }, extra))\n  }\n\n  sendSticker (chatId, sticker, extra) {\n    return this.callApi('sendSticker', Object.assign({ chat_id: chatId, sticker: sticker }, extra))\n  }\n\n  sendVideo (chatId, video, extra) {\n    return this.callApi('sendVideo', Object.assign({ chat_id: chatId, video: video }, extra))\n  }\n\n  sendVoice (chatId, voice, extra) {\n    return this.callApi('sendVoice', Object.assign({ chat_id: chatId, voice: voice }, extra))\n  }\n\n  sendGame (chatId, gameName, extra) {\n    return this.callApi('sendGame', Object.assign({ chat_id: chatId, game_short_name: gameName }, extra))\n  }\n\n  getChat (chatId) {\n    return this.callApi('getChat', {chat_id: chatId})\n  }\n\n  getChatAdministrators (chatId) {\n    return this.callApi('getChatAdministrators', {chat_id: chatId})\n  }\n\n  getChatMember (chatId, userId) {\n    return this.callApi('getChatMember', { chat_id: chatId, user_id: userId })\n  }\n\n  getChatMembersCount (chatId) {\n    return this.callApi('getChatMembersCount', {chat_id: chatId})\n  }\n\n  answerInlineQuery (inlineQueryId, results, extra) {\n    return this.callApi('answerInlineQuery', Object.assign({ inline_query_id: inlineQueryId, results: JSON.stringify(results) }, extra))\n  }\n\n  kickChatMember (chatId, userId) {\n    return this.callApi('kickChatMember', { chat_id: chatId, user_id: userId })\n  }\n\n  leaveChat (chatId) {\n    return this.callApi('leaveChat', {chat_id: chatId})\n  }\n\n  unbanChatMember (chatId, userId) {\n    return this.callApi('unbanChatMember', { chat_id: chatId, user_id: userId })\n  }\n\n  answerCallbackQuery (callbackQueryId, text, url, showAlert, cacheTime) {\n    return this.callApi('answerCallbackQuery', {\n      callback_query_id: callbackQueryId,\n      text: text,\n      url: url,\n      show_alert: showAlert,\n      cache_time: cacheTime\n    })\n  }\n\n  editMessageText (chatId, messageId, inlineMessageId, text, extra) {\n    return this.callApi('editMessageText', Object.assign({\n      chat_id: chatId,\n      message_id: messageId,\n      inline_message_id: inlineMessageId,\n      text: text\n    }, extra))\n  }\n\n  editMessageCaption (chatId, messageId, inlineMessageId, caption, markup) {\n    return this.callApi('editMessageCaption', {\n      chat_id: chatId,\n      message_id: messageId,\n      inline_message_id: inlineMessageId,\n      caption: caption,\n      reply_markup: markup\n    })\n  }\n\n  editMessageReplyMarkup (chatId, messageId, inlineMessageId, markup) {\n    return this.callApi('editMessageReplyMarkup', {\n      chat_id: chatId,\n      message_id: messageId,\n      inline_message_id: inlineMessageId,\n      reply_markup: markup\n    })\n  }\n\n  sendCopy (chatId, message, extra) {\n    const type = Object.keys(replicators.copyMethods).find((type) => {\n      return message[type]\n    })\n    if (!type) {\n      throw new Error('Unsupported message type')\n    }\n    const opts = Object.assign({chat_id: chatId}, replicators[type](message), extra)\n    return this.callApi(replicators.copyMethods[type], opts)\n  }\n}\n\nTelegram.prototype.setWebHook = util.deprecate(Telegram.prototype.setWebhook, 'telegraf: `setWebHook` is deprecated. Use `setWebhook` instead. Sorry')\nTelegram.prototype.removeWebHook = util.deprecate(Telegram.prototype.deleteWebhook, 'telegraf: `removeWebHook` is deprecated. Use `deleteWebhook` instead.')\n\nmodule.exports = Telegram\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/helpers/replicators.js":"module.exports = {\n  copyMethods: {\n    'text': 'sendMessage',\n    'audio': 'sendAudio',\n    'document': 'sendDocument',\n    'photo': 'sendPhoto',\n    'sticker': 'sendSticker',\n    'video': 'sendVideo',\n    'voice': 'sendVoice',\n    'contact': 'sendContact',\n    'location': 'sendLocation',\n    'venue': 'sendVenue'\n  },\n  text: (message) => {\n    const result = {\n      text: message.text\n    }\n    if (!message.entities) {\n      return result\n    }\n    message.entities.reverse().forEach((entity) => {\n      switch (entity.type) {\n        case 'bold':\n          result.text = insert(result.text, entity.offset + entity.length, '</b>')\n          result.text = insert(result.text, entity.offset, '<b>')\n          break\n        case 'italic':\n          result.text = insert(result.text, entity.offset + entity.length, '</i>')\n          result.text = insert(result.text, entity.offset, '<i>')\n          break\n        case 'code':\n          result.text = insert(result.text, entity.offset + entity.length, '</code>')\n          result.text = insert(result.text, entity.offset, '<code>')\n          break\n        case 'pre':\n          result.text = insert(result.text, entity.offset + entity.length, '</pre>')\n          result.text = insert(result.text, entity.offset, '<pre>')\n          break\n        case 'text_link':\n          result.text = insert(result.text, entity.offset + entity.length, '</a>')\n          result.text = insert(result.text, entity.offset, `<a href=\"${entity.url}\">`)\n          break\n        default:\n          return\n      }\n      result.parse_mode = 'HTML'\n    })\n    return result\n  },\n  contact: (message) => {\n    return {\n      phone_number: message.contact.phone_number,\n      first_name: message.contact.first_name,\n      last_name: message.contact.last_name\n    }\n  },\n  location: (message) => {\n    return {\n      latitude: message.location.latitude,\n      longitude: message.location.longitude\n    }\n  },\n  venue: (message) => {\n    return {\n      latitude: message.venue.location.latitude,\n      longitude: message.venue.location.longitude,\n      title: message.venue.title,\n      address: message.venue.address,\n      foursquare_id: message.venue.foursquare_id\n    }\n  },\n  voice: (message) => {\n    return {\n      voice: message.voice.file_id,\n      duration: message.voice.duration,\n      caption: message.caption\n    }\n  },\n  audio: (message) => {\n    return {\n      audio: message.audio.file_id,\n      duration: message.audio.duration,\n      performer: message.audio.performer,\n      title: message.audio.title,\n      caption: message.caption\n    }\n  },\n  video: (message) => {\n    return {\n      video: message.video.file_id,\n      caption: message.caption,\n      duration: message.video.duration,\n      width: message.video.width,\n      height: message.video.height\n    }\n  },\n  document: (message) => {\n    return {\n      document: message.document.file_id,\n      caption: message.caption\n    }\n  },\n  sticker: (message) => {\n    return {\n      sticker: message.sticker.file_id\n    }\n  },\n  photo: (message) => {\n    return {\n      photo: message.photo[message.photo.length - 1].file_id,\n      caption: message.caption\n    }\n  }\n}\n\nfunction insert (input, index, string) {\n  return index > 0\n    ? input.substring(0, index) + string + input.substring(index, input.length)\n    : string + input\n}\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/network/client.js":"const debug = require('debug')('telegraf:api')\nconst crypto = require('crypto')\nconst fetch = require('node-fetch')\nconst fs = require('fs')\nconst https = require('https')\nconst path = require('path')\nconst TelegramError = require('./error')\nconst MultipartStream = require('./multipart-stream')\n\nconst { isStream } = MultipartStream\n\nconst webhookBlacklist = [\n  'getChat',\n  'getChatAdministrators',\n  'getChatMember',\n  'getChatMembersCount',\n  'getFile',\n  'getFileLink',\n  'getGameHighScores',\n  'getMe',\n  'getUserProfilePhotos',\n  'getWebhookInfo'\n]\n\nconst defaultExtensions = {\n  photo: 'jpg',\n  audio: 'mp3',\n  voice: 'ogg',\n  sticker: 'webp',\n  video: 'mp4'\n}\n\nconst defaultOptions = {\n  apiRoot: 'https://api.telegram.org',\n  webhookReply: true,\n  agent: new https.Agent({\n    keepAlive: true,\n    keepAliveMsecs: 10000\n  })\n}\n\nclass ApiClient {\n  constructor (token, options, webhookResponse) {\n    this.token = token\n    this.options = Object.assign({}, defaultOptions, options)\n    this.response = webhookResponse\n  }\n\n  set webhookReply (enable) {\n    this.options.webhookReply = enable\n  }\n\n  get webhookReply () {\n    return this.options.webhookReply\n  }\n\n  callApi (method, extra = {}) {\n    const isMultipart = Object.keys(extra).find((x) => extra[x] && (extra[x].source || extra[x].url))\n    if (this.options.webhookReply && this.response && !this.response.finished && !isMultipart && !webhookBlacklist.includes(method)) {\n      debug('▷ webhook', method)\n      extra.method = method\n      if (!this.response.headersSent) {\n        this.response.setHeader('connection', 'keep-alive')\n        this.response.setHeader('content-type', 'application/json')\n      }\n      this.response.end(JSON.stringify(extra))\n      return Promise.resolve({webhook: true})\n    }\n\n    if (!this.token) {\n      throw new TelegramError({\n        error_code: 401,\n        description: 'Bot Token is required'\n      })\n    }\n\n    debug('▶︎ http', method)\n    const buildPayload = isMultipart ? this.buildFormDataPayload(extra) : this.buildJSONPayload(extra)\n    return buildPayload\n      .then((payload) => {\n        payload.agent = this.options.agent\n        return fetch(`${this.options.apiRoot}/bot${this.token}/${method}`, payload)\n      })\n      .then((res) => res.text())\n      .then((text) => {\n        try {\n          return JSON.parse(text)\n        } catch (err) {\n          throw new TelegramError({\n            error_code: 500,\n            description: 'Unsupported message received from Telegram',\n            response: text\n          })\n        }\n      })\n      .then((data) => {\n        if (!data.ok) {\n          throw new TelegramError(data)\n        }\n        return data.result\n      })\n  }\n\n  buildJSONPayload (options) {\n    return Promise.resolve({\n      method: 'POST',\n      headers: { 'content-type': 'application/json', 'connection': 'keep-alive' },\n      body: JSON.stringify(options)\n    })\n  }\n\n  buildFormDataPayload (options) {\n    if (options.reply_markup && typeof options.reply_markup !== 'string') {\n      options.reply_markup = JSON.stringify(options.reply_markup)\n    }\n    const boundary = crypto.randomBytes(30).toString('hex')\n    const formData = new MultipartStream(boundary)\n    const tasks = Object.keys(options).filter((key) => options[key]).map((key) => {\n      const value = options[key]\n      const valueType = typeof value\n      if (valueType === 'string' || valueType === 'boolean' || valueType === 'number') {\n        return formData.addPart({\n          headers: { 'content-disposition': `form-data; name=\"${key}\"` },\n          body: `${value}`\n        })\n      }\n      let fileName = value.filename || `${key}.${defaultExtensions[key] || 'dat'}`\n      if (value.url) {\n        return fetch(value.url).then((res) => {\n          formData.addPart({\n            headers: { 'content-disposition': `form-data; name=\"${key}\";filename=\"${fileName}\"` },\n            body: res.body\n          })\n        })\n      }\n      if (value.source) {\n        if (fs.existsSync(value.source)) {\n          fileName = value.filename || path.basename(value.source)\n          value.source = fs.createReadStream(value.source)\n        }\n        if (isStream(value.source) || Buffer.isBuffer(value.source)) {\n          return formData.addPart({\n            headers: { 'content-disposition': `form-data; name=\"${key}\";filename=\"${fileName}\"` },\n            body: value.source\n          })\n        }\n      }\n      throw new Error('Invalid file descriptor')\n    })\n    return Promise.all(tasks).then(() => {\n      return {\n        method: 'POST',\n        headers: { 'content-type': `multipart/form-data; boundary=${boundary}`, 'connection': 'keep-alive' },\n        body: formData\n      }\n    })\n  }\n}\n\nmodule.exports = ApiClient\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/network/error.js":"class TelegramError extends Error {\n  constructor (payload = {}) {\n    super(`${payload.error_code}: ${payload.description}`)\n    this.code = payload.error_code\n    this.description = payload.description\n    this.retryAfter = payload.retry_after\n    this.migrateToChatId = payload.migrate_to_chat_id\n  }\n}\n\nmodule.exports = TelegramError\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/network/multipart-stream.js":"const stream = require('stream')\nconst { SandwichStream } = require('sandwich-stream')\nconst CRNL = '\\r\\n'\n\nclass MultipartStream extends SandwichStream {\n  constructor (boundary = Math.random().toString(36).slice(2)) {\n    super({\n      head: `--${boundary}${CRNL}`,\n      tail: `${CRNL}--${boundary}--`,\n      separator: `${CRNL}--${boundary}${CRNL}`\n    })\n  }\n\n  addPart (part) {\n    part = part || {}\n    const partStream = new stream.PassThrough()\n    if (part.headers) {\n      for (let key in part.headers) {\n        const header = part.headers[key]\n        partStream.write(`${key}:${header}${CRNL}`)\n      }\n    }\n    partStream.write(CRNL)\n    if (MultipartStream.isStream(part.body)) {\n      part.body.pipe(partStream)\n    } else {\n      partStream.end(part.body)\n    }\n    this.add(partStream)\n  }\n\n  static isStream (stream) {\n    return stream && typeof stream === 'object' && typeof stream.pipe === 'function'\n  }\n}\n\nmodule.exports = MultipartStream\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/network/webhook.js":"const debug = require('debug')('telegraf:webhook')\n\nmodule.exports = function (path, updateHandler, errorHandler) {\n  return (req, res, next) => {\n    if (req.method !== 'POST' || req.url !== `${path}`) {\n      if (next && typeof next === 'function') {\n        return next()\n      }\n      res.statusCode = 403\n      return res.end()\n    }\n    let body = ''\n    req.on('data', (chunk) => {\n      body += chunk.toString()\n    })\n    req.on('end', () => {\n      let update = {}\n      try {\n        update = JSON.parse(body)\n      } catch (error) {\n        res.writeHead(415)\n        res.end()\n        return errorHandler(error)\n      }\n      updateHandler(update, res)\n        .then(() => {\n          if (!res.finished) {\n            res.end()\n          }\n        })\n        .catch((err) => {\n          debug('webhook error', err)\n          res.writeHead(500)\n          res.end()\n        })\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/core/composer.js":"class Composer {\n  constructor (...handlers) {\n    this.handler = Composer.compose(handlers)\n  }\n\n  use (...fns) {\n    this.handler = Composer.compose([this.handler, ...fns])\n    return this\n  }\n\n  on (updateTypes, ...fns) {\n    return this.use(Composer.mount(updateTypes, Composer.compose(fns)))\n  }\n\n  hears (triggers, ...fns) {\n    return this.use(Composer.hears(triggers, Composer.compose(fns)))\n  }\n\n  command (commands, ...fns) {\n    return this.use(Composer.command(commands, Composer.compose(fns)))\n  }\n\n  action (triggers, ...fns) {\n    return this.use(Composer.action(triggers, Composer.compose(fns)))\n  }\n\n  gameQuery (...fns) {\n    return this.use(Composer.gameQuery(Composer.compose(fns)))\n  }\n\n  middleware () {\n    return this.handler\n  }\n\n  static reply (...args) {\n    return (ctx) => ctx.reply(...args)\n  }\n\n  static fork (middleware) {\n    return (ctx, next) => {\n      setImmediate(unwrap(middleware), ctx)\n      return next()\n    }\n  }\n\n  static passThru () {\n    return (ctx, next) => next()\n  }\n\n  static lazy (fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('Argument must be a function')\n    }\n    return (ctx, next) => Promise.resolve(fn(ctx))\n      .then((middleware) => {\n        const handler = unwrap(middleware)\n        return handler(ctx, next)\n      })\n  }\n\n  static log (logFn = console.log) {\n    return Composer.fork((ctx) => logFn(JSON.stringify(ctx.update, null, 2)))\n  }\n\n  static branch (test, trueMiddleware, falseMiddleware) {\n    if (typeof test !== 'function') {\n      return test ? trueMiddleware : falseMiddleware\n    }\n    return Composer.lazy((ctx) => Promise.resolve(test(ctx)).then((value) => value ? trueMiddleware : falseMiddleware))\n  }\n\n  static optional (test, ...fns) {\n    return Composer.branch(test, Composer.compose(fns), Composer.passThru())\n  }\n\n  static dispatch (test, handlers) {\n    if (typeof test !== 'function') {\n      return handlers[test] || Composer.passThru()\n    }\n    return Composer.lazy((ctx) => Promise.resolve(test(ctx)).then((value) => handlers[value]))\n  }\n\n  static mount (updateType, middleware) {\n    let test = Array.isArray(updateType)\n      ? (ctx) => updateType.includes(ctx.updateType) || updateType.includes(ctx.updateSubType)\n      : (ctx) => updateType === ctx.updateType || updateType === ctx.updateSubType\n    return Composer.optional(test, middleware)\n  }\n\n  static hears (triggers, middleware) {\n    const tests = makeTests(triggers)\n    return Composer.mount('text', Composer.match(tests, middleware))\n  }\n\n  static action (triggers, middleware) {\n    const tests = makeTests(triggers)\n    return Composer.mount('callback_query', Composer.match(tests, middleware))\n  }\n\n  static match (tests, middleware) {\n    return Composer.lazy((ctx) => {\n      const text = (ctx.message && (ctx.message.caption || ctx.message.text)) || (ctx.callbackQuery && ctx.callbackQuery.data)\n      for (let test of tests) {\n        const result = test(text, ctx)\n        if (!result) {\n          continue\n        }\n        ctx.match = result\n        return middleware\n      }\n      return Composer.passThru()\n    })\n  }\n\n  static acl (userId, middleware) {\n    let whitelistFn = userId\n    if (typeof whitelistFn !== 'function') {\n      const allowed = Array.isArray(userId) ? userId : [userId]\n      whitelistFn = (ctx) => allowed.includes(ctx.from.id) || (ctx.from.username && allowed.includes(ctx.from.username))\n    }\n    return Composer.optional(whitelistFn, middleware)\n  }\n\n  static gameQuery (middleware) {\n    return Composer.mount('callback_query', Composer.optional((ctx) => ctx.callbackQuery.game_short_name, middleware))\n  }\n\n  static command (command, middleware) {\n    let commands = Array.isArray(command) ? command : [command]\n    commands = commands.map((cmd) => cmd.startsWith('/') ? cmd : `/${cmd}`)\n    return Composer.mount('text', Composer.lazy((ctx) => {\n      const text = ctx.message.text\n      const groupCommands = ctx.me && (ctx.chat.type === 'group' || ctx.chat.type === 'supergroup')\n        ? commands.map((command) => `${command}@${ctx.me}`)\n        : []\n      const hasMatch = ctx.message.entities && ctx.message.entities.find((entity) => {\n        const command = text.substring(entity.offset, entity.offset + entity.length)\n        return entity.type === 'bot_command' && (commands.includes(command) || groupCommands.includes(command))\n      })\n      return hasMatch ? middleware : Composer.passThru()\n    }))\n  }\n\n  static compose (middlewares) {\n    if (!Array.isArray(middlewares)) {\n      throw new Error('Middlewares must be an array')\n    }\n    return (ctx, next) => {\n      let index = -1\n      return execute(0)\n      function execute (i) {\n        if (i <= index) {\n          return Promise.reject(new Error('next() called multiple times'))\n        }\n        index = i\n        let handler = unwrap(middlewares[i]) || next\n        if (!handler) {\n          return Promise.resolve()\n        }\n        try {\n          return Promise.resolve(handler(ctx, () => execute(i + 1)))\n        } catch (err) {\n          return Promise.reject(err)\n        }\n      }\n    }\n  }\n}\n\nfunction unwrap (handler) {\n  return handler && typeof handler.middleware === 'function'\n    ? handler.middleware()\n    : handler\n}\n\nfunction makeTests (triggers) {\n  if (!Array.isArray(triggers)) {\n    triggers = [triggers]\n  }\n  return triggers.map((trigger) => {\n    if (!trigger) {\n      throw new Error('Invalid trigger')\n    }\n    if (typeof trigger === 'function') {\n      return trigger\n    }\n    return trigger instanceof RegExp\n      ? (value) => trigger.exec(value || '')\n      : (value) => trigger === value ? value : null\n  })\n}\n\nmodule.exports = Composer\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/core/context.js":"const updateTypes = [\n  'inline_query',\n  'callback_query',\n  'message',\n  'edited_message',\n  'chosen_inline_result',\n  'channel_post',\n  'edited_channel_post'\n]\n\nconst messageSubTypes = [\n  'text',\n  'sticker',\n  'photo',\n  'video',\n  'audio',\n  'document',\n  'game',\n  'voice',\n  'contact',\n  'location',\n  'venue',\n  'new_chat_member',\n  'left_chat_member',\n  'new_chat_title',\n  'new_chat_photo',\n  'delete_chat_photo',\n  'group_chat_created',\n  'supergroup_chat_created',\n  'channel_chat_created',\n  'migrate_to_chat_id',\n  'migrate_from_chat_id',\n  'pinned_message'\n]\n\nclass TelegrafContext {\n  constructor (update, telegram, options) {\n    this.tg = telegram\n    this.update = update\n    this.options = options\n    if ('message' in this.update) {\n      this.updateType = 'message'\n      this.updateSubType = messageSubTypes.find((key) => key in this.update.message)\n    } else {\n      this.updateType = updateTypes.find((key) => key in this.update)\n    }\n  }\n\n  get me () {\n    return this.options && this.options.username\n  }\n\n  get telegram () {\n    return this.tg\n  }\n\n  get message () {\n    return this.update.message\n  }\n\n  get editedMessage () {\n    return this.update.edited_message\n  }\n\n  get inlineQuery () {\n    return this.update.inline_query\n  }\n\n  get chosenInlineResult () {\n    return this.update.chosen_inline_result\n  }\n\n  get channelPost () {\n    return this.update.channel_post\n  }\n\n  get editedChannelPost () {\n    return this.update.edited_channel_post\n  }\n\n  get callbackQuery () {\n    return this.update.callback_query\n  }\n\n  get chat () {\n    return (this.message && this.message.chat) ||\n      (this.editedMessage && this.editedMessage.chat) ||\n      (this.callbackQuery && this.callbackQuery.message && this.callbackQuery.message.chat) ||\n      (this.channelPost && this.channelPost.message && this.channelPost.message.chat) ||\n      (this.editedChannelPost && this.editedChannelPost.message && this.editedChannelPost.message.chat)\n  }\n\n  get from () {\n    return (this.message && this.message.from) ||\n      (this.editedMessage && this.editedMessage.from) ||\n      (this.callbackQuery && this.callbackQuery.from) ||\n      (this.inlineQuery && this.inlineQuery.from) ||\n      (this.channelPost && this.channelPost.from) ||\n      (this.editedChannelPost && this.editedChannelPost.from) ||\n      (this.chosenInlineResult && this.chosenInlineResult.from)\n  }\n\n  get state () {\n    if (!this.contextState) {\n      this.contextState = {}\n    }\n    return this.contextState\n  }\n\n  set state (val) {\n    this.contextState = Object.assign({}, val)\n  }\n\n  assertShortcut (value, method) {\n    if (!value) {\n      throw new Error(`${method} is not available for ${this.updateType}`)\n    }\n  }\n\n  answerInlineQuery (...args) {\n    this.assertShortcut(this.inlineQuery, 'answerInlineQuery')\n    return this.telegram.answerInlineQuery(this.inlineQuery.id, ...args)\n  }\n\n  answerCallbackQuery (...args) {\n    this.assertShortcut(this.callbackQuery, 'answerCallbackQuery')\n    return this.telegram.answerCallbackQuery(this.callbackQuery.id, ...args)\n  }\n\n  editMessageText (text, extra) {\n    this.assertShortcut(this.callbackQuery, 'editMessageText')\n    return this.callbackQuery.inline_message_id\n      ? this.telegram.editMessageText(undefined, undefined, this.callbackQuery.inline_message_id, text, extra)\n      : this.telegram.editMessageText(this.chat.id, this.callbackQuery.message.message_id, undefined, text, extra)\n  }\n\n  editMessageCaption (caption, markup) {\n    this.assertShortcut(this.callbackQuery, 'editMessageCaption')\n    return this.callbackQuery.inline_message_id\n      ? this.telegram.editMessageCaption(undefined, undefined, this.callbackQuery.inline_message_id, caption, markup)\n      : this.telegram.editMessageCaption(this.chat.id, this.callbackQuery.message.message_id, undefined, caption, markup)\n  }\n\n  editMessageReplyMarkup (markup) {\n    this.assertShortcut(this.callbackQuery, 'editMessageReplyMarkup')\n    return this.callbackQuery.inline_message_id\n      ? this.telegram.editMessageReplyMarkup(undefined, undefined, this.callbackQuery.inline_message_id, markup)\n      : this.telegram.editMessageReplyMarkup(this.chat.id, this.callbackQuery.message.message_id, undefined, markup)\n  }\n\n  reply (...args) {\n    this.assertShortcut(this.chat, 'reply')\n    return this.telegram.sendMessage(this.chat.id, ...args)\n  }\n\n  getChat (...args) {\n    this.assertShortcut(this.chat, 'getChat')\n    return this.telegram.getChat(this.chat.id, ...args)\n  }\n\n  leaveChat (...args) {\n    this.assertShortcut(this.chat, 'leaveChat')\n    return this.telegram.leaveChat(this.chat.id, ...args)\n  }\n\n  getChatAdministrators (...args) {\n    this.assertShortcut(this.chat, 'getChatAdministrators')\n    return this.telegram.getChatAdministrators(this.chat.id, ...args)\n  }\n\n  getChatMember (...args) {\n    this.assertShortcut(this.chat, 'getChatMember')\n    return this.telegram.getChatMember(this.chat.id, ...args)\n  }\n\n  getChatMembersCount (...args) {\n    this.assertShortcut(this.chat, 'getChatMembersCount')\n    return this.telegram.getChatMembersCount(this.chat.id, ...args)\n  }\n\n  replyWithPhoto (...args) {\n    this.assertShortcut(this.chat, 'replyWithPhoto')\n    return this.telegram.sendPhoto(this.chat.id, ...args)\n  }\n\n  replyWithAudio (...args) {\n    this.assertShortcut(this.chat, 'replyWithAudio')\n    return this.telegram.sendAudio(this.chat.id, ...args)\n  }\n\n  replyWithDocument (...args) {\n    this.assertShortcut(this.chat, 'replyWithDocument')\n    return this.telegram.sendDocument(this.chat.id, ...args)\n  }\n\n  replyWithSticker (...args) {\n    this.assertShortcut(this.chat, 'replyWithSticker')\n    return this.telegram.sendSticker(this.chat.id, ...args)\n  }\n\n  replyWithVideo (...args) {\n    this.assertShortcut(this.chat, 'replyWithVideo')\n    return this.telegram.sendVideo(this.chat.id, ...args)\n  }\n\n  replyWithGame (...args) {\n    this.assertShortcut(this.chat, 'replyWithGame')\n    return this.telegram.sendGame(this.chat.id, ...args)\n  }\n\n  replyWithVoice (...args) {\n    this.assertShortcut(this.chat, 'replyWithVoice')\n    return this.telegram.sendVoice(this.chat.id, ...args)\n  }\n\n  replyWithChatAction (...args) {\n    this.assertShortcut(this.chat, 'replyWithChatAction')\n    return this.telegram.sendChatAction(this.chat.id, ...args)\n  }\n\n  replyWithLocation (...args) {\n    this.assertShortcut(this.chat, 'replyWithLocation')\n    return this.telegram.sendLocation(this.chat.id, ...args)\n  }\n\n  replyWithVenue (...args) {\n    this.assertShortcut(this.chat, 'replyWithVenue')\n    return this.telegram.sendVenue(this.chat.id, ...args)\n  }\n\n  replyWithContact (...args) {\n    this.assertShortcut(this.chat, 'replyWithContact')\n    return this.telegram.sendContact(this.chat.id, ...args)\n  }\n\n  replyWithMarkdown (markdown, extra) {\n    return this.reply(markdown, Object.assign({parse_mode: 'Markdown'}, extra))\n  }\n\n  replyWithHTML (html, extra) {\n    return this.reply(html, Object.assign({parse_mode: 'HTML'}, extra))\n  }\n}\n\nmodule.exports = TelegrafContext\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/helpers/extra.js":"const ReplyMarkup = require('./markup')\n\nclass Extra {\n  constructor (opts) {\n    this.load(opts)\n  }\n\n  load (opts) {\n    if (opts) {\n      Object.assign(this, opts)\n    }\n    return this\n  }\n\n  inReplyTo (messageId) {\n    this.reply_to_message_id = messageId\n    return this\n  }\n\n  notifications (value = true) {\n    this.disable_notification = !value\n    return this\n  }\n\n  webPreview (value = true) {\n    this.disable_web_page_preview = !value\n    return this\n  }\n\n  markup (markup) {\n    if (typeof markup === 'function') {\n      markup = markup(new ReplyMarkup())\n    }\n    this.reply_markup = Object.assign({}, markup)\n    return this\n  }\n\n  HTML (value = true) {\n    this.parse_mode = value ? 'HTML' : undefined\n    return this\n  }\n\n  markdown (value = true) {\n    this.parse_mode = value ? 'Markdown' : undefined\n    return this\n  }\n\n  static inReplyTo (messageId) {\n    return new Extra().inReplyTo(messageId)\n  }\n\n  static notifications (value) {\n    return new Extra().notifications(value)\n  }\n\n  static webPreview (value) {\n    return new Extra().webPreview(value)\n  }\n\n  static load (opts) {\n    return new Extra(opts)\n  }\n\n  static markup (markup) {\n    return new Extra().markup(markup)\n  }\n\n  static HTML (value) {\n    return new Extra().HTML(value)\n  }\n\n  static markdown (value) {\n    return new Extra().markdown(value)\n  }\n}\n\nExtra.Markup = ReplyMarkup\n\nmodule.exports = Extra\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/helpers/markup.js":"const util = require('util')\n\nclass Markup {\n  forceReply (value = true) {\n    this.force_reply = value\n    return this\n  }\n\n  removeKeyboard (value = true) {\n    this.remove_keyboard = value\n    return this\n  }\n\n  selective (value = true) {\n    this.selective = value\n    return this\n  }\n\n  extra () {\n    return { reply_markup: Object.assign({}, this) }\n  }\n\n  keyboard (buttons, options) {\n    const keyboard = buildKeyboard(buttons, Object.assign({columns: 1}, options))\n    if (keyboard && keyboard.length > 0) {\n      this.keyboard = keyboard\n    }\n    return this\n  }\n\n  resize (value = true) {\n    this.resize_keyboard = value\n    return this\n  }\n\n  oneTime (value = true) {\n    this.one_time_keyboard = value\n    return this\n  }\n\n  inlineKeyboard (buttons, options) {\n    const keyboard = buildKeyboard(buttons, Object.assign({columns: buttons.length}, options))\n    if (keyboard && keyboard.length > 0) {\n      this.inline_keyboard = keyboard\n    }\n    return this\n  }\n\n  button (text, hide) {\n    return Markup.button(text, hide)\n  }\n\n  contactRequestButton (text, hide) {\n    return Markup.contactRequestButton(text, hide)\n  }\n\n  locationRequestButton (text, hide) {\n    return Markup.locationRequestButton(text, hide)\n  }\n\n  urlButton (text, url, hide) {\n    return Markup.urlButton(text, url, hide)\n  }\n\n  callbackButton (text, data, hide) {\n    return Markup.callbackButton(text, data, hide)\n  }\n\n  gameButton (text, hide) {\n    return Markup.gameButton(text, hide)\n  }\n\n  static removeKeyboard (value) {\n    return new Markup().removeKeyboard(value)\n  }\n\n  static forceReply (value) {\n    return new Markup().forceReply(value)\n  }\n\n  static keyboard (buttons, options) {\n    return new Markup().keyboard(buttons, options)\n  }\n\n  static inlineKeyboard (buttons, options) {\n    return new Markup().inlineKeyboard(buttons, options)\n  }\n\n  static resize (value = true) {\n    return new Markup().resize(value)\n  }\n\n  static oneTime (value = true) {\n    return new Markup().oneTime(value)\n  }\n\n  static button (text, hide) {\n    return { text: text, hide: hide }\n  }\n\n  static contactRequestButton (text, hide = false) {\n    return { text: text, request_contact: true, hide: hide }\n  }\n\n  static locationRequestButton (text, hide = false) {\n    return { text: text, request_location: true, hide: hide }\n  }\n\n  static urlButton (text, url, hide = false) {\n    return { text: text, url: url, hide: hide }\n  }\n\n  static callbackButton (text, data, hide = false) {\n    return { text: text, callback_data: data, hide: hide }\n  }\n\n  static switchToChatButton (text, value, hide = false) {\n    return { text: text, switch_inline_query: value, hide: hide }\n  }\n\n  static switchToCurrentChatButton (text, value, hide = false) {\n    return { text: text, switch_inline_query_current_chat: value, hide: hide }\n  }\n\n  static gameButton (text, hide = false) {\n    return { text: text, callback_game: {}, hide: hide }\n  }\n}\n\nfunction buildKeyboard (buttons, options) {\n  const result = []\n  if (!Array.isArray(buttons)) {\n    return result\n  }\n  if (buttons.find(Array.isArray)) {\n    return buttons.map(row => row.filter((button) => !button.hide))\n  }\n  const opts = Object.assign({ wrap: (btn, index, currentRow) => currentRow.length >= opts.columns }, options)\n  let currentRow = []\n  let index = 0\n  for (const btn of buttons.filter((button) => !button.hide)) {\n    if (opts.wrap(btn, index, currentRow) && currentRow.length > 0) {\n      result.push(currentRow)\n      currentRow = []\n    }\n    currentRow.push(btn)\n    index++\n  }\n  if (currentRow.length > 0) {\n    result.push(currentRow)\n  }\n  return result\n}\n\nMarkup.hideKeyboard = util.deprecate(Markup.removeKeyboard, 'telegraf: `hideKeyboard` is deprecated. Use `removeKeyboard` instead.')\nMarkup.prototype.hideKeyboard = util.deprecate(Markup.prototype.removeKeyboard, 'telegraf: `hideKeyboard` is deprecated. Use `removeKeyboard` instead.')\n\nmodule.exports = Markup\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/core/session.js":"module.exports = function (opts) {\n  opts = Object.assign({\n    sessionName: 'session',\n    getSessionKey: (ctx) => ctx.from && ctx.chat && `${ctx.from.id}:${ctx.chat.id}`\n  }, opts)\n\n  const store = new Map()\n  return (ctx, next) => {\n    const key = opts.getSessionKey(ctx)\n    if (!key) {\n      return next()\n    }\n    let session = store.get(key) || {}\n    Object.defineProperty(ctx, opts.sessionName, {\n      get: function () { return session },\n      set: function (newValue) { session = Object.assign({}, newValue) }\n    })\n    try {\n      return next()\n    } finally {\n      store.set(key, session)\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-telegraf/node_modules/telegraf/lib/core/router.js":"const { compose, lazy, passThru } = require('./composer')\n\nclass Router {\n  constructor (routeFn) {\n    if (!routeFn) {\n      throw new Error('Missing routing function')\n    }\n    this.routeFn = routeFn\n    this.handlers = new Map()\n    this.otherwiseHandler = passThru()\n  }\n\n  on (route, ...fns) {\n    if (fns.length === 0) {\n      throw new TypeError('At least one handler must be provided')\n    }\n    this.handlers.set(route, compose(fns))\n    return this\n  }\n\n  otherwise (...fns) {\n    if (fns.length === 0) {\n      throw new TypeError('At least one otherwise handler must be provided')\n    }\n    this.otherwiseHandler = compose(fns)\n    return this\n  }\n\n  middleware () {\n    return lazy((ctx) => {\n      return this.routeFn(ctx).then((result) => {\n        if (!result || !result.route || !this.handlers.has(result.route)) {\n          return this.otherwiseHandler\n        }\n        Object.assign(ctx, result.context)\n        Object.assign(ctx.state, result.state)\n        return this.handlers.get(result.route)\n      })\n    })\n  }\n}\n\nmodule.exports = Router\n"}